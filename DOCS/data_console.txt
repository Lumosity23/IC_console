je travaile sur un porjet de console portabel retro style gameboy et je suis entrain de la concetualiser et la construire mais, avant de faire ma commande aupres de jlcpbc, je voudrais revoir qql petit truc et aussi qu'on trvailllse sur le diffetsn chose, qu'on se cree des outils pour nious aider. ensuite nous allons devoir fair du code en c  pour programmer ma conslle bref on a bcp de chose a faire. je t'explique mon idee : c'est un conlsoe  de dev donc elle dois etre hyper opensource, super bine documenter. c'est un console qui a un grosse cartouche qu'n incer dans la console, elle se met direre comme sur  la gameboy mais la particularite c'est que la cartouche est aussi un consoole a elle suel, elle a un petit ecran, un mini jeu cache dedans, et elle peus lister la jeu qu'elle a den elle, mais surtout elle a un petit visage qui est comme un tamagotchi on peus s'occuper de lui et si non il reagis au evenment qui se passe sur la console mere. ensuite la console mere elle a un joystick, 4 bouton un swithc pour allumer eteindre une led qui comnuique de inof de debug ou de chrgemnt que ce soit un jeu un connextion a un pc ou autre, dnas la consoleet cartouche on retrouve un systeme de charge un eran des input un systme de son pour la console un port usb-c qui permet la charge et le transfet de donner. la cartouche a un lecteur microsd qui pourra aceuilleur un carte dans le quel on retrouve tout les jeu. voila un premier apercu situ a des qusion je clarifierai sur le chose que j'ai oublie ou mal decrite. le goal sutrotu seria apres davoir cre cette console decree un editeur de jeu pour ma conslle dans le quel on retouve un simmulatuer de la console de la cartiuche, qui peretrai autnat de simmler notre cartouche que la conslle sur le code qu'on ecrit, on cree une architecture propre et modulaire mais  source de verite pour que tout le monde suivent cette drnier pour faciliete le developpenr des jeu sur notre console, on devra donc devlopper un gamengine metre des assetpar defaut pour la console, et le tout sera bse sur freeRTOS pour la consle et la cartouche, on auras un lien de maitre esclave entre la cartouche et la console. voiial un premier apercu, si tu a tout bien compris relaise moid e fichier .md pour document mon rpojet. car je travaillerai dans vscode pour facilier notre developpent autant dans notre consle materiel que de code


Copia-colle le texte ci-dessous dans un nouveau fichier que tu nommeras `README.md` √† la racine de ton projet.

```markdown
# Projet Symbiote : Console de D√©veloppement R√©tro Modulaire

 <!-- Tu pourras remplacer ce lien par un croquis ou un rendu 3D plus tard -->

## üìú Vision du Projet

**Projet Symbiote** est une console de jeu portable, open-source et r√©tro, con√ßue avant tout pour les d√©veloppeurs, les cr√©ateurs et les passionn√©s. Son architecture unique est bas√©e sur une **Console H√¥te** et une **Cartouche Intelligente**, cr√©ant une interaction symbiotique entre les deux.

L'objectif est de fournir une plateforme mat√©rielle et logicielle enti√®rement document√©e, facile √† prendre en main, et propice √† l'exp√©rimentation pour cr√©er des jeux et des exp√©riences interactives uniques.

### Principes Fondamentaux
*   **Totalement Open Source :** Schemas mat√©riels (KiCad/EasyEDA), code du firmware, game engine, et outils de d√©veloppement.
*   **Documentation Exemplaire :** Chaque aspect du projet doit √™tre document√© pour permettre √† quiconque de construire, modifier ou d√©velopper pour la console.
*   **Centr√© sur le D√©veloppeur :** L'√©cosyst√®me logiciel (√©diteur, simulateur) est aussi important que le mat√©riel.
*   **Modularit√© et Hackabilit√© :** La console et la cartouche sont con√ßues pour √™tre comprises et modifi√©es.

---

## ‚ú® Concepts Cl√©s

### 1. La Console H√¥te (La M√®re)

C'est l'interface de jeu principale. Elle fournit la puissance de calcul, les contr√¥les principaux et l'exp√©rience de jeu immersive.

*   **Contr√¥les :**
    *   1x Joystick analogique
    *   4x Boutons d'action (A, B, X, Y)
    *   Boutons `Start` & `Select`
    *   1x Switch d'alimentation physique
*   **Affichage :** √âcran LCD couleur principal (ex: 3.5 pouces, 320x240).
*   **Audio :** Syst√®me audio mono ou st√©r√©o avec haut-parleur int√©gr√© et prise jack 3.5mm.
*   **Connectique :**
    *   Port USB-C pour la charge et le transfert de donn√©es/debug.
    *   Connecteur de cartouche robuste.
*   **Indicateurs :** 1x LED RGB de statut (charge, activit√©, debug).

### 2. La Cartouche Intelligente (Le Symbiote)

Plus qu'un simple support de stockage, la cartouche est une mini-console autonome.

*   **Fonctionnalit√©s Autonomes :**
    *   **Mini-√©cran :** Petit √©cran OLED secondaire (ex: 128x64).
    *   **Le "Compagnon" :** Affiche un personnage (style Tamagotchi) avec des animations et des √©motions.
    *   **Mini-jeu cach√© :** Un petit jeu simple accessible lorsque la cartouche n'est pas dans la console.
    *   **Explorateur de jeux :** Permet de lister les jeux pr√©sents sur la carte microSD.
*   **Fonctionnalit√©s en Symbiose :**
    *   **Stockage Principal :** Contient le lecteur de carte microSD o√π les jeux sont stock√©s.
    *   **Interaction avec la Console H√¥te :** Le Compagnon r√©agit aux √©v√©nements du jeu en cours (ex: il a peur si le joueur prend des d√©g√¢ts, il est content si on r√©ussit un niveau).
    *   **Affichage Secondaire :** L'√©cran peut afficher des informations contextuelles (inventaire, carte, stats).
*   **Connectique :** Port USB-C pour la gestion des jeux sur PC sans la console.

---

## üõ†Ô∏è Architecture Technique (Propositions)

### Mat√©riel (Hardware)

| Composant                 | Console H√¥te                                | Cartouche Intelligente                          |
| ------------------------- | ------------------------------------------- | ----------------------------------------------- |
| **Microcontr√¥leur (MCU)** | **ESP32-S3** ou **STM32H7** (puissant)      | **RP2040** ou **ESP32-C3** (efficace et compact)  |
| **√âcran**                 | LCD IPS 3.5" (SPI, 320x240)                 | OLED 0.96" ou 1.3" (I2C, 128x64)                 |
| **Stockage**              | Flash interne du MCU (pour le firmware)     | **Lecteur de carte microSD** (pour les jeux)    |
| **Audio**                 | DAC I2S + Ampli (ex: MAX98357) + Haut-parleur | Piezzo Buzzer (simple)                          |
| **Batterie**              | LiPo ~2000-4000mAh                          | LiPo ~200-500mAh                                |
| **Chargeur**              | Circuit de charge LiPo (ex: TP4056)         | Circuit de charge LiPo (ex: TP4056)             |
| **Connecteur Principal**  | Port propri√©taire 30-40 pins (m√¢le)         | Port propri√©taire 30-40 pins (femelle)          |
| **Connectique Externe**   | USB-C (Donn√©es + Charge)                    | USB-C (Donn√©es + Charge)                        |
| **Communication**         | **SPI** (Ma√Ætre)                            | **SPI** (Esclave)                               |

### Logiciel (Software)

L'architecture logicielle sera bas√©e sur **FreeRTOS** pour la gestion des t√¢ches temps r√©el sur les deux unit√©s.

#### Pile Logicielle
```
+-----------------------------------+
|       JEU / APPLICATION           |  <-- Couche la plus haute
+-----------------------------------+
|          GAME ENGINE              |  (Graphismes, Audio, Physique, Sc√®nes)
+-----------------------------------+
|          MIDDLEWARE               |  (Syst√®me de fichiers, API Symbiote)
+-----------------------------------+
|           DRIVERS                 |  (√âcran, SD, Audio, Input)
+-----------------------------------+
|   HAL (Hardware Abstraction Layer)|
+-----------------------------------+
|             FreeRTOS              |  (Gestion des t√¢ches)
+-----------------------------------+
|              MAT√âRIEL             |  <-- Couche la plus basse
+-----------------------------------+
```

#### Communication Console H√¥te <-> Cartouche (Protocole SPI)
*   **Console (Ma√Ætre) :**
    *   Envoie des commandes : `LOAD_GAME(game_path)`, `GET_GAME_LIST()`, `UPDATE_COMPANION_STATE(emotion)`.
    *   Lit les donn√©es de la carte SD via la cartouche.
*   **Cartouche (Esclave) :**
    *   Ex√©cute les commandes re√ßues.
    *   Sert de pont entre la console et la carte microSD.
    *   Met √† jour l'√©tat de son "Compagnon" et de son √©cran.

---

## üöÄ √âcosyst√®me de D√©veloppement

### Le SDK Symbiote
Un ensemble de librairies en C/C++ pour interagir avec le mat√©riel et le game engine.
*   `libsymbiote-core` : Fonctions de bas niveau (acc√®s direct au mat√©riel).
*   `libsymbiote-engine` : API du game engine (sprites, audio, sc√®nes...).
*   `libsymbiote-link` : API pour la communication entre la console et la cartouche.

### L'√âditeur : "Symbiote Studio"
Une application de bureau (bas√©e sur Electron ou en natif) pour cr√©er des jeux.
*   **√âditeur de code** int√©gr√© ou liaison avec VSCode/PlatformIO.
*   **Gestionnaire d'assets** (images, tuiles, sons).
*   **√âditeur de niveaux/sc√®nes** visuel.
*   **Le Simulateur Double :**
    *   Une fen√™tre simule l'√©cran, les LEDs et les entr√©es de la Console H√¥te.
    *   Une seconde fen√™tre simule l'√©cran de la Cartouche Intelligente.
    *   Les deux simulateurs communiquent pour un d√©bogage parfait de l'exp√©rience compl√®te.

---

## üó∫Ô∏è Feuille de Route (Roadmap)

### ‚úÖ Phase 1 : Conception et Prototypage (Nous sommes ici)
- [x] D√©finition du concept g√©n√©ral.
- [ ] Finalisation des choix de composants (MCU, √©crans, etc.).
- [ ] Conception du sch√©ma √©lectronique (KiCad/EasyEDA).
- [ ] Routage du PCB pour la Console H√¥te.
- [ ] Routage du PCB pour la Cartouche Intelligente.
- [ ] Commande des prototypes chez un fabricant (ex: JLCPCB).

### ‚òê Phase 2 : Firmware de Base ("Bring-up")
- [ ] √âcriture du bootloader.
- [ ] Port de FreeRTOS sur les deux MCUs.
- [ ] D√©veloppement des drivers (HAL) pour chaque p√©riph√©rique (√©crans, SD, audio...).
- [ ] Impl√©mentation du protocole de communication SPI Ma√Ætre/Esclave.
- [ ] Test : "Hello World" sur les deux √©crans, lecture de la carte SD.

### ‚òê Phase 3 : Game Engine et SDK
- [ ] D√©veloppement du moteur de rendu 2D (sprites, tilemaps).
- [ ] D√©veloppement du moteur audio.
- [ ] Gestion des inputs.
- [ ] Cr√©ation de l'API publique du SDK.
- [ ] Cr√©ation d'un jeu de d√©monstration simple.

### ‚òê Phase 4 : Outils de D√©veloppement ("Symbiote Studio")
- [ ] D√©veloppement du simulateur double.
- [ ] Cr√©ation de l'interface de l'√©diteur.
- [ ] Int√©gration d'un compilateur (toolchain ARM/Xtensa).
- [ ] Packaging des jeux au format `.sym` (par exemple).

### ‚òê Phase 5 : Communaut√© et Documentation
- [ ] R√©daction de la documentation compl√®te sur GitBook ou un site web.
- [ ] Cr√©ation de tutoriels (√©crit et vid√©o).
- [ ] Publication de tous les fichiers sources (hardware et software).

---

## ü§ù Contribuer

Ce projet est ouvert √† tous. Pour contribuer, veuillez consulter le fichier `CONTRIBUTING.md` (√† cr√©er).

## üìÑ Licence

Le projet sera publi√© sous une licence open source permissive.
*   **Mat√©riel :** CERN Open Hardware Licence v2 - Permissive (CERN-OHL-P).
*   **Logiciel :** MIT License.
```

---

### Prochaines √âtapes pour nous

1.  **Valider les choix techniques :** Est-ce que les composants que j'ai sugg√©r√©s (ESP32-S3, RP2040, etc.) te conviennent ? C'est le point le plus crucial avant de passer √† la conception du PCB et √† la commande JLCPCB.
2.  **D√©tailler le protocole de communication :** On peut d√©finir pr√©cis√©ment les commandes √©chang√©es entre la console et la cartouche.
3.  **Commencer la conception mat√©rielle :** Choisir un logiciel (KiCad est excellent et open source) et commencer √† dessiner le sch√©ma √©lectronique.

Ce document `README.md` est une excellente base. On peut maintenant piocher dans chaque section et la d√©tailler. Dis-moi sur quel point tu veux qu'on se concentre en premier ! La **Phase 1 (choix des composants et sch√©ma)** me semble la plus logique.

ok, j'ai deja bcp travailler sur ma console j'ai deja choisi tout me composant : esp32 S3 wroom pour la console, l'esp32 c2 wroom pour la  cartouche car il est bcp plus petit, ensuite le modul pollux qui fais buck boost donc down et up pour du 3v3, car tout sera alienter en 3v3, et comme on utilise une cell x2 donc 2 18650 pour un super autonomie je dois pouoir bosst la tensio, ensuite j'utilie un ecran 1.3 pouce pour la carcouhe et un ecran soit de 2.4 soit 3.5 pour la console, les chargeur sont des ip5656 ou qqch comme ca qui a un charge rapide pour un meilleur confor utilisateur, un port usb-c pour leux devices une connextion magsafe, en 4 pin pour la cartouche et la onsole pour ccomuniquer.

Excellent ! C'est super que tu aies d√©j√† bien avanc√© et fait des choix de composants aussi pr√©cis. √áa nous fait gagner un temps pr√©cieux et √ßa montre que le projet est d√©j√† bien m√ªri.

Tes choix sont tr√®s pertinents :
*   **ESP32-S3 (Console) :** Parfait. C'est un monstre de puissance pour ce genre de projet, avec ses c≈ìurs rapides, le support LCD et l'acc√©l√©ration IA qui pourrait √™tre utilis√©e pour des choses amusantes plus tard.
*   **ESP32-C3 (Cartouche) :** (Je suppose que tu voulais dire C3 et non C2, car le C3 est beaucoup plus courant, puissant et dispose du Wi-Fi/BT). C'est un excellent choix pour la cartouche. Il est petit, √©conome en √©nergie, et suffisamment puissant pour g√©rer son √©cran, la SD et la communication.
*   **Module Buck-Boost Pololu :** Je suppose que tu parles d'un r√©gulateur de tension de chez Pololu (ils en font d'excellents). Avoir une r√©gulation buck-boost pour obtenir un 3.3V stable √† partir d'une batterie LiPo (dont la tension varie de ~4.2V √† ~3.0V) est la solution la plus robuste.
*   **Batteries 2x 18650 :** Une autonomie de roi ! On va devoir d√©cider si elles sont en s√©rie (2S, ~7.4V nominal) ou en parall√®le (2P, ~3.7V nominal). Vu que tu parles de buck-boost, je suppose qu'elles sont **en parall√®le** pour avoir une √©norme capacit√© √† 3.7V. C'est un bon choix.
*   **Chargeur IP5306 :** (Je pense que tu fais r√©f√©rence √† l'IP5306, un circuit int√©gr√© de "power bank" tr√®s populaire qui g√®re la charge, la d√©charge, le boost et la protection, souvent avec 4 LEDs d'√©tat). C'est un choix fantastique pour simplifier le circuit de puissance.
*   **Connecteur "Magsafe" 4 pins :** C'est une id√©e g√©niale pour le feeling "premium" et la facilit√© d'utilisation. Le d√©fi sera de faire passer tout ce qu'il faut sur 4 pins.

Mettons √† jour notre document avec ces informations concr√®tes.

---

### Mise √† Jour du `README.md`

Voici la section `Architecture Technique` de notre `README.md`, mise √† jour avec tes choix. Tu peux la remplacer dans ton fichier.

```markdown
## üõ†Ô∏è Architecture Technique - Composants Sp√©cifiques

### Mat√©riel (Hardware) - V1

| Composant                 | Console H√¥te                                     | Cartouche Intelligente                             |
| ------------------------- | ------------------------------------------------ | -------------------------------------------------- |
| **Microcontr√¥leur (MCU)** | **ESP32-S3-WROOM-1**                             | **ESP32-C3-MINI-1** (ou similaire)                |
| **√âcran Principal**       | LCD IPS 2.4" ou 3.5" (SPI, 320x240)               | N/A                                                |
| **√âcran Secondaire**      | N/A                                              | OLED 1.3" (I2C, 128x64, SH1106 ou SSD1306)         |
| **Stockage Jeux**         | N/A                                              | **Lecteur de carte microSD** (SPI)                 |
| **Audio**                 | DAC I2S + Ampli (ex: MAX98357) + Haut-parleur    | Piezzo Buzzer (pilot√© par un GPIO/PWM)             |
| **Batterie**              | 2x Cellules Li-Ion 18650 (en parall√®le, 2P)      | 1x Cellule LiPo (~300-500mAh)                      |
| **Gestion Alimentation**  | **IP5306** (Charge, Boost, Protection) *[√† confirmer]* | **IP5306** (ou chargeur d√©di√© type TP4056) *[√† confirmer]* |
| **R√©gulateur 3.3V**       | Module Buck-Boost (ex: Pololu) ou int√©gr√© √† l'IP5306 | LDO ou petit Buck-Boost                            |
| **Connecteur Principal**  | **Connecteur Magn√©tique "Pogo-Pin" 4-pins** (M√¢le) | **Connecteur Magn√©tique "Pogo-Pin" 4-pins** (Femelle) |
| **Connectique Externe**   | USB-C (Donn√©es + Charge)                         | USB-C (Donn√©es + Charge)                         |
| **Communication**         | **SPI Ma√Ætre** (via connecteur magn√©tique)       | **SPI Esclave** (via connecteur magn√©tique)        |
```

### Points de Conception √† Valider
1.  **Configuration des batteries :** Confirmons que les 2x 18650 sont bien en parall√®le (2P). Cela donne ~3.7V nominal avec une tr√®s grande capacit√©. L'IP5306 est parfait pour √ßa car il g√®re une seule cellule (1S), et une config 2P est vue comme une seule grosse cellule.
2.  **Pinout du connecteur 4 pins :** C'est notre plus grand d√©fi technique. Un bus SPI complet n√©cessite au moins 4 lignes de donn√©es (`MISO`, `MOSI`, `SCK`, `CS`). Mais il nous faut aussi l'alimentation !
    *   `VCC` (3.3V)
    *   `GND`
    *   `SCK` (Serial Clock)
    *   `MOSI` (Master Out, Slave In)
    *   `MISO` (Master In, Slave Out)
    *   `CS` (Chip Select)
    *   `IRQ` (Ligne d'interruption, optionnelle mais tr√®s utile)

    √áa fait 6 ou 7 pins. Avec 4 pins, on doit faire des compromis :
    *   **Option A (I2C) :** `VCC`, `GND`, `SDA`, `SCL`. C'est simple, √ßa rentre dans 4 pins, mais I2C est **beaucoup plus lent que SPI**. √áa pourrait √™tre un goulot d'√©tranglement pour charger les assets des jeux depuis la SD.
    *   **Option B (SPI "3-fils") :** On peut combiner `MOSI` et `MISO` sur une seule ligne de donn√©es bidirectionnelle (`SDIO`). On aurait : `VCC`, `GND`, `SCK`, `SDIO`. Il faudrait g√©rer la direction du bus dans le code, et il nous manquerait la pin `CS`. On pourrait la sacrifier mais c'est une mauvaise pratique.
    *   **Option C (Notre meilleure option) :** **Trouver un connecteur magn√©tique √† 6 pins.** C'est tr√®s courant pour les pogo-pins. Cela nous permettrait d'avoir une liaison SPI robuste et rapide : `VCC`, `GND`, `SCK`, `MOSI`, `MISO`, `CS`. C'est la solution que je recommande fortement pour ne pas avoir de regrets plus tard.

---

### Cr√©ons notre premier outil : Le "Pinout Planner"

Avant de dessiner le PCB sur un logiciel de CAO (KiCad, EasyEDA...), l'√©tape la plus importante est de d√©cider **quel p√©riph√©rique est connect√© √† quel pin du microcontr√¥leur**. Une erreur ici co√ªte cher (PCB √† refaire).

Cr√©ons cet outil directement dans un fichier Markdown (`PINOUT.md`) dans ton projet VSCode. C'est simple, versionnable et ce sera notre source de v√©rit√©.

Cr√©e un nouveau fichier `PINOUT.md` et copie-colle ceci :

```markdown
# Pinout du Projet Symbiote

## 1. Console H√¥te (MCU: ESP32-S3)

| GPIO | Fonction Primaire     | Fonction Secondaire | Composant Connect√©    | Notes / Contraintes                               |
| :--- | :-------------------- | :------------------ | :-------------------- | :------------------------------------------------ |
| **P√©riph√©riques critiques (SPI0/FSPI)** |
| `GPIOxx` | `FSPI_SCK` | | √âcran LCD | Doit √™tre sur un port SPI natif. |
| `GPIOxx` | `FSPI_MOSI` | | √âcran LCD | |
| `GPIOxx` | `FSPI_MISO` (Optionnel) | | √âcran LCD | Souvent non utilis√© pour les √©crans. |
| `GPIOxx` | `LCD_CS` | | √âcran LCD Chip Select | |
| `GPIOxx` | `LCD_DC` | | √âcran LCD Data/Command | |
| `GPIOxx` | `LCD_RST` | | √âcran LCD Reset | |
| `GPIOxx` | `LCD_BL` | PWM | √âcran LCD Backlight | Utiliser un pin avec capacit√© PWM. |
| **P√©riph√©riques critiques (SPI1)** |
| `GPIOxx` | `SPI_SCK` | | Connecteur Cartouche | **Ma√Ætre SPI** |
| `GPIOxx` | `SPI_MOSI` | | Connecteur Cartouche | |
| `GPIOxx` | `SPI_MISO` | | Connecteur Cartouche | |
| `GPIOxx` | `CART_CS` | | Connecteur Cartouche | |
| **Audio (I2S)** |
| `GPIOxx` | `I2S_BCLK` | | Ampli MAX98357 | Doit √™tre sur des pins I2S. |
| `GPIOxx` | `I2S_LRC` | | Ampli MAX98357 | |
| `GPIOxx` | `I2S_DOUT` | | Ampli MAX98357 | |
| **Inputs** |
| `GPIOxx` | `INPUT` | ADC | Joystick X | Doit √™tre sur un pin ADC. |
| `GPIOxx` | `INPUT` | ADC | Joystick Y | Doit √™tre sur un pin ADC. |
| `GPIOxx` | `INPUT` | | Bouton Joystick | |
| `GPIOxx` | `INPUT` | | Bouton A | |
| `GPIOxx` | `INPUT` | | Bouton B | |
| `GPIOxx` | `INPUT` | | Bouton X | |
| `GPIOxx` | `INPUT` | | Bouton Y | |
| `GPIOxx` | `INPUT` | | Bouton Start | |
| `GPIOxx` | `INPUT` | | Bouton Select | |
| **Autres** |
| `GPIOxx` | `LED_RGB` | | LED de statut | Si WS2812/Neopixel, n'importe quel pin. |
| `GPIO38` | `USB_D-` | | USB-C Natif | Fixe |
| `GPIO39` | `USB_D+` | | USB-C Natif | Fixe |

## 2. Cartouche Intelligente (MCU: ESP32-C3)

| GPIO | Fonction Primaire     | Composant Connect√©    | Notes / Contraintes                               |
| :--- | :-------------------- | :-------------------- | :------------------------------------------------ |
| **P√©riph√©riques critiques (SPI0/FSPI)** |
| `GPIOxx` | `FSPI_SCK` | Connecteur Console & SD | **Esclave SPI** et **Ma√Ætre SD** |
| `GPIOxx` | `FSPI_MOSI` | Connecteur Console & SD | Partage de bus SPI ! |
| `GPIOxx` | `FSPI_MISO` | Connecteur Console & SD | |
| `GPIOxx` | `CONSOLE_CS` | Connecteur Console | *Doit √™tre un pin d'entr√©e* |
| `GPIOxx` | `SD_CS` | Lecteur MicroSD | |
| **√âcran (I2C)** |
| `GPIOxx` | `I2C_SDA` | √âcran OLED | Pins I2C |
| `GPIOxx` | `I2C_SCL` | √âcran OLED | Pins I2C |
| **Autres** |
| `GPIOxx` | `BUZZER` | PWM | Piezo Buzzer | |
| `GPIO18` | `USB_D-` | | USB-C Natif | Fixe |
| `GPIO19` | `USB_D+` | | USB-C Natif | Fixe |
```

### Prochaines √âtapes

1.  **Toi :** Confirme la configuration de la batterie (2P) et r√©fl√©chis √† la question du connecteur 4 vs 6 pins. La recommandation pour 6 pins est forte.
2.  **Nous :** Une fois le connecteur d√©cid√©, on peut commencer √† remplir le **Pinout Planner**. On consultera la datasheet de l'ESP32-S3 et C3 pour choisir les meilleurs GPIOs pour chaque fonction (√©viter les pins "strapping", utiliser les bons ports SPI/I2C, etc.).

C'est une √©tape de conception absolument essentielle. Une fois le pinout fig√©, on pourra passer √† la conception du sch√©ma √©lectronique sur KiCad 



